
    <!doctype html>
    <html lang="ja">
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>画面遷移から考えるNuxtアプリケーションをアクセシブルにする方法</title>
        <meta name="og:title" content="画面遷移から考えるNuxtアプリケーションをアクセシブルにする方法">
        <meta name="og:description" content="やまのくのVue Fes Japan 2023の登壇資料">
        <meta name="og:image" content="https://yamanoku.net/vuefes-japan-2023/images/ogp.png">
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:site" content="@yamanoku">
        <meta name="twitter:image:alt" content="How to make Nuxt applications accessible based on page transitions">
        <meta property="og:locale" content="ja">
        <link rel="stylesheet" href="https://cdn.skypack.dev/yama-normalize">
        <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
        <link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/styles/a11y-dark.min.css">
        <script type="module">hljs.highlightAll()</script>
        <style>code{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,monospace;font-size:1em;}pre code.hljs{padding:calc(var(--rhythm)*3);}footer{padding: var(--y-rhythm-3);text-align: center;}</style>
      </head>
      <body>
        <main id="main">
          <h1><span style="word-break: keep-all; overflow-wrap: anywhere;">画面遷移から<wbr>考える<wbr>Nuxtアプリケーションを<wbr>アクセシブルに<wbr>する<wbr>方法</span></h1>
          <p><img src="../images/title-ja.png" alt="スライドタイトル：画面遷移から考えるNuxtアプリケーションをアクセシブルにする方法"></p>
<h2>翻訳記事一覧</h2>
<p><a href="https://yamanoku.net/vuefes-japan-2023/ja/" target="_blank" rel="noopener">日本語ページ</a> / <a href="https://yamanoku.net/vuefes-japan-2023/en/" target="_blank" rel="noopener">English page</a></p>
<h2>はじめに</h2>
<p>はじめに自己紹介です。</p>
<img src="../images/yamanoku-icon.png" alt="写真：やまのく" width="256" height="256">
<p><a href="https://yamanoku.net" target="_blank" rel="noopener">やまのく</a>と申します。</p>
<p><a href="https://crowdworks.co.jp/" target="_blank" rel="noopener">株式会社クラウドワークス</a>にて、フロントエンドエンジニアとして施策の開発やデザインシステムの開発にも携わっておりました。現在は技術的負債解消をリードするチームに所属し、レガシーフロントエンド環境の刷新に関わっております。</p>
<p>ウェブの仕様についてやウェブアクセシビリティにまつわることに興味があります。</p>
<p>また、一児の父でゴールデン・レトリバーと3匹の猫の飼い主をやっております。</p>
<p>本題に入る前に今回のテーマに関わる<strong>ウェブアクセシビリティ</strong>とはなにかを説明します。</p>
<p>アクセシビリティとはアクセスと能力の単語を組み合わせたもので、情報や製品、サービスが利用できるようにする意味で使われる言葉です。略して<em>A11y</em>とも書かれていることがあります。</p>
<p><img src="../images/accessibility-a11y.png" alt="Access + Ability = Accessibility (A11y)"></p>
<p>ウェブアクセシビリティはウェブの文脈にて考えられるアクセシビリティのことで「利用者の障害の有無やその程度、年齢や利用環境にかかわらず、ウェブで提供されている情報やサービスを利用できること、またはその到達度」とされています。</p>
<p>ウェブアクセシビリティについてお話しする際に、最初に理解しておくべき重要なポイントがあります。それは、「元々ウェブはアクセシブルなもの」ということです。</p>
<p>ここで、コロナ禍で多くの人々がリモート勤務を余儀なくされた時期を思い出してみてください。その時、私たちはオンラインで情報を得たり、発信したりすることが可能でした。</p>
<p>これは、ウェブという媒体を通じて物事がアクセシブルになっている一例です。</p>
<p>そんなウェブのおかげで障害当事者もウェブサービスを通じることでさまざまなものにアクセスできるようになっています。</p>
<ul>
<li>Web検索</li>
<li>ニュース・新聞の閲覧</li>
<li>ブログ・SNSの閲覧</li>
<li>外出時のナビゲーション</li>
<li>乗り換え検索</li>
<li>ショッピング、金融サービスの口座の状況確認</li>
<li>マイポータルやマイナンバーカードを利用した各種手続き等</li>
</ul>
<p>これは視覚障害者向けの支援技術の利用状況に関する調査によるもので、彼らがパソコンやスマートフォンを介してさまざまなサービスを利用していることが明らかになっています。</p>
<p>ウェブアクセシビリティを確保することは、障害を持つ人々に対しても公平なサービスを提供するための手段であり、これにより様々な背景を持つ人々がサービスを利用できるようになります。</p>
<p>今回<a href="https://vuefes.jp/2023/" target="_blank" rel="noopener">Vue Fes Japan 2023</a>ということで日本とウェブアクセシビリティに関するタイムリーな話題についてを紹介します。</p>
<p>それは<strong>改正障害者差別解消法</strong>と<strong>環境の整備</strong>についてです。</p>
<p>障害者差別解消法は障害を理由とする差別の解消と、障害のある人もない人も、互いにその人らしさを認め合いながら共に生きる社会を実現することを目的とする法律です。</p>
<p>この法律により、障害がある人々を不公平に差別するのではなく、彼らが日常生活を送る上で直面する困難を和らげたり、解決したりするための措置や配慮が求められます。</p>
<p>来年の4月からは、障害のある人々への合理的な配慮を提供することが、民間企業においても努力義務ではなく法的な義務化になります。</p>
<p><strong>合理的配慮</strong>とは、障害を持つ人が社会に参加する際に必要な特別な支援や調整を指します。これにはさまざまな形があります。</p>
<p>例として、障害を持つ人が筆記が難しい場合に代筆をしてもらう、コミュニケーションを取る際に、絵カードや写真カードやタブレット端末を使用してみる、肢体不自由な人が移動する際には、移動のサポートを提供することも合理的配慮の一環と言えます。</p>
<p>合理的配慮は、障害を持つ人が困難を感じた際、その人の個別のニーズに応じて無理のない範囲で対応していく必要があります。</p>
<p>ですが、合理的配慮が必要な人との関係が長期にわたる場合、毎回対応をすることが双方にとって負担となることがあります。この負担を減らすため、効率的かつ持続可能なサポート方法を検討することが欠かせません。</p>
<p>事前に改善措置を施しておくことで、さまざまな場面で障害を持つ個々の人々への合理的配慮をスムーズに行えるようになるのですが、これを<strong>環境の整備</strong>と言います。</p>
<p>例えば、聴覚障害者と筆談でコミュニケーションを取る必要がある状況では、タブレットなどの入力装置を準備しておくことで、その人自身が入力できるようにし、都度の対応や外部からの支援を必要としなくなります。</p>
<p>ウェブアクセシビリティは、合理的配慮そのものではなく、事前的な措置として行う環境の整備で行うためのものとしての位置づけです。</p>
<p>先ほどの合理的配慮で説明したように、これまで電話や筆談でしか対応できなかったことも、ウェブを介して行うことで非同期的に、そして支援技術を利用して個々人が自分で問い合わせや入力を行えるようになります。</p>
<p>ウェブアクセシビリティを実現することで、利用者の満足度が向上し、対応や問い合わせが減少することで全体の業務効率が向上することが期待されています。</p>
<p>そんなウェブアクセシビリティの重要性を理解したうえで立ち返ってほしいことがあります。</p>
<p>それは私たちがこれまでに作ってきた、そして現在作っているVue.jsやNuxt.jsを使用したアプリケーションが実際にアクセシブルであるかどうか、ということです。</p>
<p>前回のVue Fes Japanでは「<a href="https://yamanoku.net/vuefes-japan-online-2022/ja/" target="_blank" rel="noopener">Vue.jsでアクセシブルなコンポーネントをつくるために</a>」をテーマに、誤ったアクセシビリティ対応についてや、Vue.jsの強みを活かしたアクセシビリティへの配慮とテストについて話させていただきました。</p>
<p>その際<a href="https://webaim.org/" target="_blank" rel="noopener">WebAIM</a>という団体によるクライアントサイドフレームワークのアクセシビリティの対応状況を取り上げました。</p>
<p><img src="../images/the-webaim-million-2023.png" alt="The WebAIM Million 2023のJavaScriptフレームワークの結果。Vue.jsでのアクセシビリティ対応は平均より20.9%も低い結果が出ている"></p>
<p>数字は改善傾向にありますが、2023年時点でも結果がまだ悪いことが私個人としては気になっています。</p>
<p>私を含むVue.jsやNuxt.jsを用いる開発者たちが、ウェブアクセシビリティを正確に考慮した開発を継続できるよう、今回の発表でもその点を話すことができればと考えています。</p>
<p>今回は「画面遷移」におけるアクセシビリティに焦点を当てて話を進めていきたいと思います。</p>
<p>改めてよろしくお願いいたします。</p>
<h3>クライアントサイドルーティングという手法</h3>
<p>まず初めに、<strong>クライアントサイドルーティング</strong>という手法について説明しましょう。</p>
<p>通常の画面遷移では、サーバーサイドが新しいページのHTMLを生成し、それをクライアントに送信して画面を表示します。これが一般的なルーティングの形になります。一方で、クライアントサイドルーティングは全ての処理をクライアント側で完結させる手法です。</p>
<p>この手法は、シングルページアプリケーションや画面内の一部を動的に更新する際に利用されます。</p>
<p>クライアントサイドルーティングにはいくつかの利点があります。</p>
<ul>
<li>ページナビゲーションが早い</li>
<li>クライアントサイドで状態を保持したまま移動ができる</li>
<li>2つ以上のレイアウトを入れ子にするNasted Layoutsでの活用</li>
<li>カスタマイズされたページ間のトランジションアニメーションができる</li>
</ul>
<p>これらの特長は、ウェブサイトやアプリケーションのユーザー体験を向上させる上で大いに役立ちます。</p>
<p>ページ間のトランジションアニメーションといえば、最近さまざまなクライアントフレームワークで導入されつつある<a href="https://developer.mozilla.org/ja/docs/Web/API/View_Transitions_API" target="_blank" rel="noopener">View Transitions API</a>があります。Nuxt.jsでは<a href="https://nuxt.com/blog/v3-4" target="_blank" rel="noopener">バージョン3.4からexperimentalで導入</a>されています。</p>
<p>現在はView Trainsitions API非対応ブラウザでのフォールバックがないため、そのまま使用する場合は対応するブラウザのみでしか動かないことに注意です。</p>
<p>実際のデモを見てみましょう。</p>
<p><video src="https://user-images.githubusercontent.com/904724/231222082-6bd4aeae-3026-407e-b3be-658df6305748.mp4" controls style="width: 100%; border: 1px solid var(--y-image-border-color);" loop></video></p>
<p>画面遷移するごとにクリックした対象部分が拡大されているような効果が入っています。</p>
<p>異なる２要素間にトランジション効果をつけることができるため、ページ全体やコンポーネント単一でのトランジションはできたものから更に一段階上の画面遷移を実現できるようになります。</p>
<p>スムーズな画面遷移を実現するための手法も増えて、導入障壁も下がりつつあるため、シングルページアプリケーションが出始めた当初よりクライアントサイドルーティングはより身近なものとなってきたと思います。</p>
<h2>画面遷移におけるアクセシビリティの問題点</h2>
<p>より便利に身近になってきたクライアントサイドルーティングですが、それによって見逃してしまうアクセシビリティの問題は存在します。次は問題点についてと、その問題の解決策についてを紹介していきます。</p>
<h3>何が変化したかが支援技術に伝わらない</h3>
<p>まず１つに何が変化したかが支援技術に伝わらないというのがあります。これは画面遷移のアクセシビリティを考慮する際に最も気付きづらい問題です。</p>
<p>クライアントサイドルーティングを用いた画面遷移は、視覚的にはどの部分が変わったのか明確に捉えることができるかもしれません。しかし、支援技術を利用してページを閲覧しているユーザーはその変化に気づきにくい可能性があります。</p>
<p>画面内のものを読み上げてくれる支援技術のスクリーンリーダーを使用してクライアントサイドルーティングの様子を見てみましょう。</p>
<p><video src="../videos/demo-movie-01.mov" controls style="width: 100%; border: 1px solid var(--y-image-border-color);"></video></p>
<p>このように画面上では適切にページが切り替わっているものの、スクリーンリーダーを使用しているユーザーにはその変化が通知されないことが分かるかと思います。</p>
<p>このような問題はどのように回避すればよいのでしょうか。</p>
<p>解決する手段の１つとしてWebコンテンツをよりアクセシブルにするための技術仕様であるWAI-ARIAを活用した<a href="https://developer.mozilla.org/ja/docs/Web/Accessibility/ARIA/ARIA_Live_Regions" target="_blank" rel="noopener">ARIAライブリージョン</a>というものがあります。ARIAライブリージョンは、動的なコンテンツ変更をユーザーに通知するために使用されます。</p>
<p>画面遷移時にユーザーに通知を行うアクセシブルな方法として、ARIAライブリージョンを利用して <code>title</code> 要素の変更を通知する手法があります。</p>
<p>具体的な手法を説明していきます。</p>
<p>まずはページ単位で <code>useHead</code> からそのページの <code>title</code> を指定します。</p>
<pre><code class="language-ts">useHead({
  title: 'About Page',
});
</code></pre>
<p>次にタイトル要素を取得してきて、ページが移動する度に変更を検知させます。</p>
<pre><code class="language-ts">const route = useRoute();
const message = ref&lt;string&gt;(&quot;&quot;);

const announceRoute = () =&gt; {
  const title = document.title;
  message.value = title;
};

onMounted(() =&gt; {
  announceRoute();
});

watch(
  () =&gt; route.fullPath,
  () =&gt; {
    setTimeout(() =&gt; {
      announceRoute()
    }, 300);
  }
);
</code></pre>
<p>今回の例では Route のパスを検知した上で変更させています。<code>setTimeout</code> を使用して少し遅延させることで、支援技術によっては直ちに反映されない通知の取得タイミングのズレを補正しています。</p>
<p>そして通知させるための変数をHTML側に組み込みます。</p>
<pre><code class="language-html">&lt;p
  role=&quot;status&quot;
  aria-live=&quot;assertive&quot;
  class=&quot;visually-hidden&quot;
&gt;
  ｛｛ message ｝｝
&lt;/p&gt;
</code></pre>
<p><code>aria-live</code> というWAI-ARIAを使用することで支援技術に通知させるようにできています。値は <code>assertive</code> を使用することで変更が即座にアナウンスされ、ユーザーの注意を引くことができます。</p>
<p>対応するHTML要素はスクリーンリーダーが検知する目的のみに使用されるため、通常は画面上では非表示になるようにします。</p>
<pre><code class="language-css">.visually-hidden {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
}
</code></pre>
<p>ここで注意することとしては <code>display: none</code> で非表示にすると支援技術では存在を検知できないため<strong>視覚的にだけ</strong>見えないようにする必要があります。このスタイル手法は通称<a href="https://www.a11yproject.com/posts/how-to-hide-content/" target="_blank" rel="noopener">Visually Hidden</a>と呼ばれているものです。</p>
<p>それでは変更したものを一緒に見てみましょう。</p>
<p><video src="../videos/demo-movie-02.mov" controls style="width: 100%; border: 1px solid var(--y-image-border-color);"></video></p>
<p>このようにしてリンクが押された場合に画面が切り替わっていることを通知できるようになりました。</p>
<p>Nuxt.jsで作られたマストドンクライアントの「<a href="https://github.com/elk-zone/elk" target="_blank" rel="noopener">elk</a>（エルク）」ではこの手法をコンポーネントとして活用しています。</p>
<ul>
<li><a href="https://github.com/elk-zone/elk/blob/5d09e7d2ab473d3fe049ace8468455baa18de9b2/components/aria/AriaAnnouncer.vue" target="_blank" rel="noopener">elk/components/aria/AriaAnnouncer.vue</a></li>
</ul>
<p>支援技術を利用してページを確認する際には、ページが読み込まれた後に現在のページタイトルがアナウンスされるのを聞くことができます。</p>
<p>ソースコードは公開されているので、興味がある方は実際のアプリケーションがどのように動作するのかを確認しながら、チェックしてみてください。</p>
<h3>フォーカスマネジメント</h3>
<p>次に画面が切り替わったことでのキーボード操作についてです。</p>
<p>キーボード操作では、エンターキーまたはスペースキーで項目を決定したり、矢印キーで項目を移動したり、エスケープキーで操作を解除するなどの操作があります。</p>
<p>今回は、その中でも特にタブキーを使用したフォーカス移動に関する問題点をデモを通じてご紹介します。</p>
<p><video src="../videos/demo-movie-03.mov" controls style="width: 100%; border: 1px solid var(--y-image-border-color);"></video></p>
<p>ページ下部に位置するリンクを選択した際には、確かに画面のコンテンツは更新されますが、フォーカスの移動すると、以前の位置、すなわち下部のリンクからの移動となってしまいます。</p>
<p>状況によってこれが問題とならないこともありますが、今回のデモで示すような状況ではこの挙動が非常に不都合であることがはっきりと分かります。</p>
<p>こうした問題を解消するため、次に移動してほしい要素へフォーカスするための処理を挟む必要があります。</p>
<p>Vue.jsでの対象の要素を取得する場合、<code>ref</code> を使用しテンプレート参照します。</p>
<pre><code class="language-ts">const focusedRef = ref&lt;HTMLElement&gt;();
</code></pre>
<p>タブキーを使用したフォーカス移動の際には、<code>a</code> 要素や <code>button</code> 要素のようなものはデフォルトでフォーカスを受け入れることができますが、フォーカスできないものもあります。</p>
<p>この問題を解決するためには、<code>tabindex</code> 属性を使用することで、要素へフォーカス可能になるよう設定できます。</p>
<pre><code class="language-ts">onMounted(() =&gt; {
  if (focusedRef.value) {
    focusedRef.value.tabIndex = -1;
    focusedRef.value.focus();
  }
};
</code></pre>
<p>この値を <code>-1</code> に設定すると、要素は通常のキーボード操作ではフォーカスされなくなり、誤って操作されるリスクを防ぐことができます。その後、直接対象の要素をフォーカスさせています。</p>
<p>次に考えるべき点は、どの位置にフォーカスを当てるか、ということです。</p>
<p>ページを移動した際、最初にフォーカスを当てるべき位置としては、ページの主要なコンテンツを包含する <code>main</code> 要素が適していると考えられます。しかし、この方法には問題点があります。</p>
<p>具体的な例を見てみましょう。ここでは、アバウトページへ遷移した際に <code>main</code> 要素にフォーカスを当てるような動作を紹介します。</p>
<p><video src="../videos/demo-movie-04.mp4" controls style="width: 100%; border: 1px solid var(--y-image-border-color);"></video></p>
<p>気付きづらいかもしれませんが、<code>main</code> 要素にフォーカスが当たると、内包する全ての内容を一度に読み上げてしまいます。</p>
<p>今回は <code>main</code> 要素内のものが少ないため読み上げるものはわずかでしたが、実際の場合はこれよりも多いコンテンツがあることが想定されます。</p>
<p>これはWindowsで利用できる<a href="https://www.nvda.jp/" target="_blank" rel="noopener">NVDA</a>というスクリーンリーダーでの結果です。一方でmacOSのスクリーンリーダーではこのような読み上げ方をしませんが、デバイスやOSによってスクリーンリーダーの挙動は異なるため、注意が必要です。</p>
<p>では、この問題を解決するためにはどうしたらよいのでしょうか。</p>
<p>対象が大きすぎて全体を一度に読み上げてしまうのであれば、フォーカス対象の要素を小さくしてみるのが一つの方法です。</p>
<p><video src="../videos/demo-movie-05.mp4" controls style="width: 100%; border: 1px solid var(--y-image-border-color);"></video></p>
<p>ページ内に見出し要素が存在する場合は、その要素にフォーカスを移動させるように変更することをお勧めします。</p>
<p>もし見出しがない場合は、スキップリンクを用意して、そこへフォーカスを移動させ、ARIAライブリージョンでページタイトルを読み上げるのも１つの方法だと思っています。</p>
<p>スキップリンクとは、主にキーボードを使用してブラウジングするユーザーのための機能で、ページの先頭から直接メインコンテンツの開始部分へジャンプできるページ内リンクのことを指します。</p>
<p>この手法自体はウェブアクセシビリティで必須のものではありませんが、スキップリンク自体があれば使う人もいるため一定効果があるものだと考えられています。</p>
<p>GitHubでもこの方法が採用されており、ページの先頭からメインコンテンツの直前の要素に簡単に移動することができ、そこから続けてメインコンテンツにアクセスすることが可能です。</p>
<p><img src="../images/github-skip-link.png" alt="スクリーンショット：Nuxt.jsのリポジトリページで「Skip to content」というリンクが表示されている"></p>
<p>スキップリンクの作成方法に関しては、<a href="https://ja.vuejs.org/guide/best-practices/accessibility.html#skip-link" target="_blank" rel="noopener">Vue.js公式ドキュメントのアクセシビリティページ</a>でも詳しく説明されていますので、是非ご覧ください。</p>
<p>以上の内容からページ遷移した後にフォーカスする対象としては、情報量が少ない箇所を選ぶことが望ましいと言えます。</p>
<p>フォーカスの開始位置において<strong>必ずここにする</strong>という明確なルールは存在しません。状況によっては、フォーカス位置を変更しない方がユーザーにとって理解しやすい場合もあるでしょう。</p>
<p>しかし、その際にはユーザーには「位置が変わらない」という挙動を学習する必要があります。そのため、サーバーサイドでのページ遷移と同様、<strong>ブラウザの上部から遷移が始まるような形</strong>を基本としておくことが重要です。</p>
<h3>過度なアニメーションで閲覧が阻害される</h3>
<p>最後に過度なアニメーションで閲覧が阻害されるというのがあります。</p>
<p>ページトランジションアニメーションを使用することは、画面遷移の流れをスムーズにしてユーザーへの没入感を高めることができます。</p>
<p>一方で、全てのユーザーにとって最適な解決策であるとは限りません。特に前庭障害や認知障害を持つユーザーにとっては、アニメーションが原因で吐き気を催したり、混乱を引き起こしたりするリスクがあります。</p>
<p>現在のPCやスマートフォンの多くでは、OSレベルで「視差効果を減らす」設定を提供しています。</p>
<p>この設定は、画面上の動く視差効果を抑制し、より穏やかな表示に変更するものです。特にスマートフォンユーザーの中には、バッテリーの持ちを延ばすためにこの設定をONにしている方もいらっしゃるかもしれません。</p>
<p>視差効果を減らすための設定をフロントエンド側で制御する際には、<code>prefers-reduced-motion</code> を使用できます。</p>
<p>JavaScriptとWeb Animations APIを使用してアニメーション設定しているのであれば、<code>window</code> オブジェクトの <code>matchMedia</code> メソッドを使ってユーザーの設定を取得し、<code>change</code> イベントリスナーを使ってアニメーションを制御することが可能です。</p>
<pre><code class="language-js">const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
mediaQuery.addEventListener('change', () =&gt; {
  console.log(mediaQuery.media, mediaQuery.matches);
  // JavaScriptでのアニメーションを止める
});
</code></pre>
<p>ただし、この方法ではユーザーが設定を変更した時点で内容を反映させる場合、ブラウザをリロードする必要があります。</p>
<p>Vue.jsでComposition APIを使用している場合、<a href="https://vueuse.org/" target="_blank" rel="noopener">VueUse</a>という状態管理のユーティリティライブラリが使えます。この中に<a href="https://vueuse.org/core/usepreferredreducedmotion/" target="_blank" rel="noopener">視差効果に関連するコンポジション関数</a>が含まれています。</p>
<p><video src="../videos/demo-movie-06.mov" controls style="width: 100%; border: 1px solid var(--y-image-border-color);" loop></video></p>
<p>このようなツールを利用することで、よりスムーズにユーザーの設定に合わせた表示切り替えが実現できます。</p>
<p>もしCSSを使用して手早く設定を反映させたい場合、全ての要素に対して <code>animation</code> プロパティやそれに準ずるものを無効にすることで対応可能です。</p>
<pre><code class="language-css">@media (prefers-reduced-motion: reduce) {
  *,
  ::before,
  ::after {
    animation-delay: -1ms !important;
    animation-duration: 1ms !important;
    animation-iteration-count: 1 !important;
    background-attachment: initial !important;
    scroll-behavior: auto !important;
    transition-duration: 0s !important;
    transition-delay: 0s !important;
  }
}
</code></pre>
<p>また、View Transitions APIを使用している場合も、<code>animation</code> プロパティを無効に指定することでアニメーションを停止させることができます。</p>
<pre><code class="language-css">@media (prefers-reduced-motion) {
  ::view-transition-group(*),
  ::view-transition-old(*),
  ::view-transition-new(*) {
    animation: none !important;
  }
}
</code></pre>
<p>アニメーションはCSSの設定を変更することで簡単に無効化することが可能です。</p>
<p>しかし、それによって実際に違和感なく動作するかどうか、実際に確認することが必要です。
視差効果を無効化する場合だけでなく、他のケースでも同様です。</p>
<p>コード上での変更を完了しただけで満足するのではなく、変更が意図通りに機能しているかを必ず確認してください。</p>
<p>以上がNuxt.jsにおける画面遷移についてのアクセシビリティについてでした。</p>
<h2>画面遷移をWeb APIから解決する</h2>
<p>次に、Routerライブラリやフレームワークに依存しない、将来のクライアントサイドルーティングでの開発に活用できるWeb APIについて紹介していきます。</p>
<p>画面遷移に関連するWeb APIとして、多くの方が<a href="https://developer.mozilla.org/ja/docs/Web/API/History_API" target="_blank" rel="noopener">History API</a>についてを思い浮かべるでしょう。</p>
<p>かつて「Pjax」と呼ばれる<code>pushState</code>とAjaxを組み合わせたページ遷移に関する技術が利用されていました。ここで言及される<code>pushState</code>は、History APIのメソッドの一つです。</p>
<p>Vue Routerの場合、このHistory APIを模した動作を提供しており、<code>push</code>、<code>replace</code>、<code>go</code>などのメソッドが存在します。</p>
<p>ただし、History APIをそのまま使用するにはいくつか実装上の問題が発生します。</p>
<ul>
<li><code>iframe</code>内の遷移も含んでしまうため、Top Level Frameで履歴を管理しようとすると、意図しない形で履歴が破壊される可能性がある</li>
<li>ページ上で発生する<code>Navigation</code>を直接フックする方法が存在しないため、全てのリンククリックを監視する必要がある。しかしこれだけでは完璧に遷移をインタラプトすることはできない</li>
<li>遷移をインデックスで管理するため、どのインデックスがどの状態に対応しているかを別途管理する必要がある</li>
<li>History APIとブラウザの履歴との連携はブラウザによって差異がある</li>
<li><code>pushState</code>で保存する<code>state</code>には制限が多く、かつ壊れやすい</li>
</ul>
<p>これらの問題を回避し、クライアントサイドルーティングを効果的に実現するため、Vue Routerのような各種Routerライブラリが開発されました。これらのライブラリによって、History APIは隠蔽された形で利用されています。</p>
<p>Routerによりブラウザに画面遷移を通知することは可能ですが、その通知をどのタイミングで行うべきかの情報はブラウザから提供されていません。これが意味するのは、わざと通知のタイミングをずらすような実装、例えば <code>setTimeout</code> を使用するようなもの、が必要になってしまいます。</p>
<p>そうした問題を解決するために新たに策定されているものが<a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_API" target="_blank" rel="noopener">Navigation API</a>です。</p>
<p>Navigation APIはHistory APIでは解決できなかったクライアントサイドルーティングの問題点を解消してくれます。</p>
<p>このAPIを利用することで、画面遷移の開始と終了のタイミングを通知することができ、インターセプトを利用してスクロール位置の復元やフォーカス位置の調整なども行うことが可能になります。</p>
<p>特に、ページを進めるだけでなく、戻るボタンを使用した際やページのリロード時など、様々なシチュエーションで役立ちそうな機能があります。これにより、アクセシビリティを担保したユーザー体験の向上が期待できます。</p>
<p>2023年10月現在、Chromeでは実装されており動作するようになっていますが、SafariやFirefoxではまだ実装されていません。</p>
<p><img src="../images/caniuse-navigation-api.png" alt="スクリーンショット：Can I UseでのNavigation APIにまつわるブラウザ対応表"></p>
<p>しかし、ウェブの相互運用性を向上させることを目的としたプロジェクト「<a href="https://github.com/web-platform-tests/interop" target="_blank" rel="noopener">Interop</a>」において、各モダンブラウザで使用可能となるよう注力されているAPIの一つとして<a href="https://github.com/web-platform-tests/interop/issues/435" target="_blank" rel="noopener">投票されています</a>。</p>
<p>過去に注力されたAPIの例としては、Container Queries、Inert属性、スクロールに関するCSSプロパティなどがありました。</p>
<p>こちらの対応状況については今のところ予測が難しい部分もありますが、各モダンブラウザにおいて取り入れられるのはそう遠くはなさそうだと期待されています。</p>
<h2>おわりに</h2>
<p>いかがだったでしょうか。</p>
<p>今回のテーマが、これまで知らなかった方々にとって新たな学びとなり、役立つ情報が得られたならば、それは大変嬉しく思います。</p>
<p>お話しした内容が、皆様にとって知らなかったことも多いかもしれません。そのため、少し複雑に感じる部分があるかもしれませんが、ご一緒に考えていただければ幸いです。</p>
<p>最初にも触れましたが、ウェブサイトは元々アクセシブルな作りとなっていました。しかし、近年のフロントエンド開発の進化によってクライアントサイドルーティングが主流となり、以前は問題視されなかった多くのアクセシビリティの問題が表面化してきています。</p>
<p>サーバーサイドルーティングでは問題とならなかったアクセシビリティの課題が、クライアントサイドルーティングの導入により顕在化しているとも言えるでしょう。</p>
<p>誤解を恐れずに言うとクライアントサイドルーティングと言う選択肢には、既存のウェブの利点をあえて捨て去り、ゼロから複雑さに挑戦するという覚悟が必要だと私は考えています。</p>
<p>しかし、これは決して<strong>クライアントサイドルーティングを使ってはいけない</strong>と言いたいわけではありません。</p>
<p>クライアントサイドで複雑な状態を管理し、優れたユーザー体験を提供するためには、クライアントサイドルーティングのような技術が今もなお必要とされています。それらを利用することで実現可能な新しい体験や価値を、私たち開発者は追求し続けるべきだと考えています。</p>
<p>アクセシビリティを考えることは個々の開発者にとって非常に重要ですが、使用しているフレームワーク自体がアクセシビリティをどのように取り扱っているかを理解することも重要です。</p>
<p>最後に、Nuxt.jsにおけるアクセシビリティの取り組みについて触れてこの発表を終わろうと思います。</p>
<p>実は<a href="https://nuxt.com/docs/community/roadmap" target="_blank" rel="noopener">Nuxt.jsのロードマップ</a>を調べると、アクセシビリティに関連する項目が含まれていることが分かります。これは皆さんにとって嬉しい情報かもしれません。</p>
<p><img src="../images/nuxt-a11y-load-map.png" alt="スクリーンショット：Nuxt.jsのアクセシビリティロードマップが書かれたGitHub Issueページ"></p>
<p>例えば、先ほど紹介したARIAライブリージョンの実装や、アクセシビリティテストエンジンである「<a href="https://github.com/dequelabs/axe-core" target="_blank" rel="noopener">axe-core</a>」をビルトインする、ナビゲーション時のフォーカス管理など、様々なタスクが挙げられています。</p>
<p>今後、Nuxt.jsのアクセシビリティへの取り組みに・ロードマップの進展を見守りつつ、私たち自身もアクセシビリティ向上のために努めていく必要があると思っております。</p>
<p>以上で発表を終わります。ご清聴いただきありがとうございました。</p>
<h2>参考資料</h2>
<ul>
<li><a href="https://www.digital.go.jp/resources/introduction-to-web-accessibility-guidebook" target="_blank" rel="noopener">ウェブアクセシビリティ導入ガイドブック｜デジタル庁</a></li>
<li><a href="https://jbict.net/survey/at-survey-03" target="_blank" rel="noopener">第3回支援技術利用状況調査報告書 | 日本視覚障害者ICTネットワーク</a></li>
<li><a href="https://www8.cao.go.jp/shougai/suishin/sabekai_leaflet-r05.html" target="_blank" rel="noopener">リーフレット「令和６年４月１日から合理的配慮の提供が義務化されます！」 - 内閣府</a></li>
<li><a href="https://shougaisha-sabetukaishou.go.jp/goritekihairyo/" target="_blank" rel="noopener">合理的配慮の提供 | 障害者の差別解消に向けた理解促進ポータルサイト</a></li>
<li><a href="https://webaim.org/projects/million/" target="_blank" rel="noopener">WebAIM: The WebAIM Million - The 2023 report on the accessibility of the top 1,000,000 home pages</a></li>
<li><a href="https://vite-plugin-ssr.com/server-routing-vs-client-routing" target="_blank" rel="noopener">Server Routing VS Client Routing | Vike</a></li>
<li><a href="https://nuxt.com/docs/getting-started/transitions#view-transitions-api-experimental" target="_blank" rel="noopener">Transitions · Get Started with Nuxt</a></li>
<li><a href="https://www.gatsbyjs.com/blog/2019-07-11-user-testing-accessible-client-routing/" target="_blank" rel="noopener">What we learned from user testing of accessible client-side routing techniques with Fable Tech Labs | Gatsby</a>
<ul>
<li><a href="https://marcy.codes/prototypes/routing/index.html" target="_blank" rel="noopener">Accessible JavaScript Routing Prototypes</a></li>
</ul>
</li>
<li><a href="https://web.dev/articles/prefers-reduced-motion?hl=ja" target="_blank" rel="noopener">Preferreds-reduced-motion: 動きが少ないほうがよい場合もあります  |  Articles  |  web.dev</a></li>
<li><a href="https://developer.chrome.com/docs/web-platform/view-transitions/" target="_blank" rel="noopener">Smooth and simple transitions with the View Transitions API - Chrome for Developers</a></li>
<li><a href="https://blog.jxck.io/entries/2022-04-22/navigation-api.html" target="_blank" rel="noopener">Navigation API による「JS での画面遷移」と SPA の改善 | blog.jxck.io</a></li>
<li><a href="https://github.com/nuxt/nuxt/issues/23255" target="_blank" rel="noopener">Accessibility roadmap · Issue #23255 · nuxt/nuxt</a></li>
<li><a href="https://gihyo.jp/book/2023/978-4-297-13366-5" target="_blank" rel="noopener">Webアプリケーションアクセシビリティ ――今日から始める現場からの改善</a></li>
<li><a href="https://www.youtube.com/watch?v=2gESGUHjUCs" target="_blank" rel="noopener">Webアクセシビリティセミナー ～改正障害者差別解消法の2024年4月1日施行にあたり、企業は何をすべきか～ - YouTube</a></li>
</ul>

        </main>
        <footer>
          <p>Copyright 2023, Okuto Oyama</p>
          <p>Source : <a href="https://github.com/yamanoku/vuefes-japan-2023" target="_blank">yamanoku/vuefes-japan-2023</a></p>
        </footer>
      </body>
    </html>
  